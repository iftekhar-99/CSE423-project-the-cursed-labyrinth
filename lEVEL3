from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *
from OpenGL.GLUT import GLUT_BITMAP_HELVETICA_18
import math
import random

# ==========================================
# Global Configuration (Level 3: Stone Labyrinth)
# ==========================================
WINDOW_WIDTH = 1024
WINDOW_HEIGHT = 768

# Scale Factors
MAP_DIM = 100        # Slightly smaller but denser map for complexity
CELL_SIZE = 30       # Larger stones
WALL_HEIGHT = 70    

# Cell Types
C_EMPTY = 0
C_WALL = 1
C_MINE_ZONE = 2      # Zones where mines are likely
C_START = 4
C_EXIT = 5

# Map Data
map_data = []       
display_list = None 

# --- ENTITY LISTS ---
mines = []      # The new Landmine feature
particles = [] 

# --- PLAYER STATE ---
player_pos = [0, 0, 0]
player_angle = 1.57 
base_speed = 3.0
player_speed = base_speed
key_states = {}

# Stats
player_hp = 100.0
game_over = False
level_complete = False 
global_time = 0.0

# ==========================================
# 1. Map & Landmine Generation
# ==========================================
def generate_level_3():
    global map_data, player_pos, display_list, mines, particles, game_over, level_complete, player_hp
    
    # Reset State
    map_data = [[C_WALL for _ in range(MAP_DIM)] for _ in range(MAP_DIM)]
    mines = []
    particles = []
    game_over = False
    level_complete = False
    player_hp = 100.0
    
    start_x, start_y = 5, 5
    
    # --- 1. DIG COMPLEX MAZE (LOOPS) ---
    # We use more diggers with longer life to create loops
    diggers = []
    
    # Primary paths
    for _ in range(15):
        diggers.append({
            'x': random.randint(5, MAP_DIM-5), 
            'y': random.randint(5, MAP_DIM-5), 
            'life': random.randint(200, 400) # Long life for loops
        })

    # Force a path from start
    diggers.append({'x': start_x, 'y': start_y, 'life': 500})

    for digger in diggers:
        cx, cy = digger['x'], digger['y']
        life = digger['life']
        
        while life > 0:
            # Carve 
            if 0 < cx < MAP_DIM-1 and 0 < cy < MAP_DIM-1:
                map_data[cx][cy] = C_EMPTY
                
                # Chance to spawn a Landmine on this floor tile
                # "Loops within" often implies backtracking, making mines dangerous
                if random.random() < 0.05: 
                    # Don't spawn mine on start pos
                    if abs(cx - start_x) > 5 or abs(cy - start_y) > 5:
                        # Add a mine
                        mines.append({
                            'x': cx * CELL_SIZE, 
                            'y': 0, 
                            'z': cy * CELL_SIZE, 
                            'state': 'IDLE',   # IDLE, ACTIVE, EXPLODED
                            'timer': 180,      # 3 seconds * 60 FPS
                            'blink': 0
                        })

            # Random Walker Logic
            move = random.choice([(0,1), (0,-1), (1,0), (-1,0)])
            cx += move[0]
            cy += move[1]
            
            # Bound checks
            cx = max(2, min(MAP_DIM-3, cx))
            cy = max(2, min(MAP_DIM-3, cy))
            
            life -= 1

    # --- 2. START ZONE ---
    for i in range(start_x - 1, start_x + 2):
        for j in range(start_y - 1, start_y + 2):
            map_data[i][j] = C_START
            # Clear mines from start zone
            to_remove = []
            for m in mines:
                if abs(m['x'] - i*CELL_SIZE) < 50 and abs(m['z'] - j*CELL_SIZE) < 50:
                    to_remove.append(m)
            for rm in to_remove:
                if rm in mines: mines.remove(rm)

    player_pos = [start_x * CELL_SIZE, 20, start_y * CELL_SIZE]
    
    # --- 3. EXIT (Randomly placed far away) ---
    found_exit = False
    while not found_exit:
        ex = random.randint(MAP_DIM//2, MAP_DIM-2)
        ey = random.randint(MAP_DIM//2, MAP_DIM-2)
        if map_data[ex][ey] == C_EMPTY:
            map_data[ex][ey] = C_EXIT
            found_exit = True

    if display_list:
        glDeleteLists(display_list, 1)
        display_list = None

# ==========================================
# 2. Visuals
# ==========================================
def create_display_list():
    global display_list
    display_list = glGenLists(1)
    glNewList(display_list, GL_COMPILE)
    
    for x in range(MAP_DIM):
        for z in range(MAP_DIM):
            cell = map_data[x][z]
            wx = x * CELL_SIZE
            wz = z * CELL_SIZE
            
            if cell == C_WALL:
                # STONE WALLS (Gray/Dark Gray)
                glPushMatrix()
                glTranslatef(wx, WALL_HEIGHT/2, wz)
                glScalef(1, WALL_HEIGHT/CELL_SIZE, 1)
                
                # Slight variation in stone color
                col = 0.3 + random.uniform(-0.05, 0.05)
                glColor3f(col, col, col) 
                glutSolidCube(CELL_SIZE)
                glPopMatrix()
                
            elif cell == C_EMPTY or cell == C_START:
                # ROCKY GROUND (Dark Brown)
                # Brown: Red + Green (Low Blue)
                # Dark Brown: 0.4, 0.25, 0.1
                
                if (x+z)%2 == 0: glColor3f(0.35, 0.25, 0.15) 
                else: glColor3f(0.30, 0.20, 0.10) 
                
                glBegin(GL_QUADS)
                glVertex3f(wx-CELL_SIZE/2, 0, wz-CELL_SIZE/2)
                glVertex3f(wx+CELL_SIZE/2, 0, wz-CELL_SIZE/2)
                glVertex3f(wx+CELL_SIZE/2, 0, wz+CELL_SIZE/2)
                glVertex3f(wx-CELL_SIZE/2, 0, wz+CELL_SIZE/2)
                glEnd()
                
            elif cell == C_EXIT:
                # The Exit Beacon
                glPushMatrix()
                glTranslatef(wx, 10, wz)
                glColor3f(1, 1, 1) # White light
                glutSolidSphere(10, 10, 10)
                # Beam
                glBegin(GL_LINES)
                glVertex3f(0,0,0); glVertex3f(0, 200, 0)
                glEnd()
                glPopMatrix()

    glEndList()

def draw_entities():
    # 1. LANDMINES
    for m in mines:
        if m['state'] == 'EXPLODED': continue
        
        glPushMatrix()
        glTranslatef(m['x'], 2, m['z']) # Sit on floor
        
        if m['state'] == 'IDLE':
            # Hard to see - Dark Gray mound
            glColor3f(0.2, 0.2, 0.2)
            glScalef(1, 0.2, 1)
            glutSolidSphere(8, 8, 8)
            
            # Tiny red light (armed)
            glColor3f(1, 0, 0)
            glPushMatrix()
            glTranslatef(0, 5, 0)
            glutSolidSphere(1, 4, 4)
            glPopMatrix()
            
        elif m['state'] == 'ACTIVE':
            # FLASHING WARNING
            freq = (m['timer'] / 180.0) # Beeps faster as timer drops
            if int(global_time * 10) % 2 == 0:
                glColor3f(1.0, 0.0, 0.0) # Bright Red
            else:
                glColor3f(0.0, 0.0, 0.0) # Black
                
            glScalef(1.2, 0.4, 1.2) # Swells up slightly
            glutSolidSphere(10, 8, 8)
            
        glPopMatrix()

    # 2. PARTICLES (Explosions)
    for p in particles:
        glPushMatrix()
        glTranslatef(p['x'], p['y'], p['z'])
        glScalef(p['life']/10.0, p['life']/10.0, p['life']/10.0)
        
        # Explosion colors (Red/Orange/Gray)
        if random.random() < 0.5: glColor3f(1, 0, 0)
        else: glColor3f(1, 0.6, 0)
        
        glutSolidCube(3)
        glPopMatrix()

def draw_hud():
    glMatrixMode(GL_PROJECTION); glPushMatrix(); glLoadIdentity()
    gluOrtho2D(0, WINDOW_WIDTH, 0, WINDOW_HEIGHT)
    glMatrixMode(GL_MODELVIEW); glPushMatrix(); glLoadIdentity()
    glDisable(GL_DEPTH_TEST)

    glColor3f(1, 1, 1)
    glRasterPos2f(20, WINDOW_HEIGHT - 30)
    msg = f"LEVEL 3: STONE MAZE | HP: {int(player_hp)}"
    for ch in msg: glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))

    if game_over:
        glColor3f(1, 0, 0)
        glRasterPos2f(WINDOW_WIDTH/2 - 50, WINDOW_HEIGHT/2)
        for ch in "YOU DIED": glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))
        
    if level_complete:
        glColor3f(0, 1, 0)
        glRasterPos2f(WINDOW_WIDTH/2 - 80, WINDOW_HEIGHT/2)
        for ch in "MAZE ESCAPED!": glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))

    glEnable(GL_DEPTH_TEST)
    glMatrixMode(GL_PROJECTION); glPopMatrix()
    glMatrixMode(GL_MODELVIEW); glPopMatrix()

# ==========================================
# 3. Physics & Logic
# ==========================================
def update_physics():
    global player_pos, player_angle, global_time, player_hp, game_over, level_complete, mines, particles
    
    if game_over or level_complete: return

    global_time += 0.05
    
    # --- MOVEMENT ---
    move_speed = 0; strafe = 0
    if key_states.get(b'w'): move_speed = player_speed
    if key_states.get(b's'): move_speed = -player_speed
    if key_states.get(b'a'): strafe = -player_speed
    if key_states.get(b'd'): strafe = player_speed
    
    if key_states.get(GLUT_KEY_LEFT): player_angle -= 0.04
    if key_states.get(GLUT_KEY_RIGHT): player_angle += 0.04
    
    dx = math.sin(player_angle) * move_speed
    dz = -math.cos(player_angle) * move_speed
    sdx = math.sin(player_angle + 1.57) * strafe
    sdz = -math.cos(player_angle + 1.57) * strafe
    
    nx = player_pos[0] + dx + sdx
    nz = player_pos[2] + dz + sdz
    
    # Collision Logic
    gx = int(round(nx / CELL_SIZE))
    gz = int(round(nz / CELL_SIZE))
    
    if 0 <= gx < MAP_DIM and 0 <= gz < MAP_DIM:
        if map_data[gx][gz] != C_WALL:
            player_pos[0] = nx
            player_pos[2] = nz
            
            if map_data[gx][gz] == C_EXIT:
                level_complete = True
                print("LEVEL 3 COMPLETE")

    # --- LANDMINE LOGIC ---
    active_mines = []
    for m in mines:
        if m['state'] == 'EXPLODED': continue
        
        dist = math.sqrt((player_pos[0]-m['x'])**2 + (player_pos[2]-m['z'])**2)
        
        # Trigger Logic: Stepping on it (Distance < 15)
        if m['state'] == 'IDLE':
            if dist < 15:
                m['state'] = 'ACTIVE'
                print("CLICK! MINE ACTIVATED!")
        
        # Timer Logic
        if m['state'] == 'ACTIVE':
            m['timer'] -= 1
            if m['timer'] <= 0:
                m['state'] = 'EXPLODED'
                # EXPLOSION EFFECT
                for _ in range(30):
                    particles.append({
                        'x': m['x'], 'y': 5, 'z': m['z'],
                        'dx': random.uniform(-3,3), 'dy': random.uniform(1,5), 'dz': random.uniform(-3,3),
                        'life': 40
                    })
                
                # DAMAGE CHECK (If player is still near)
                # Explosion radius is 40
                if dist < 40:
                    player_hp -= 50
                    print(f"BOOM! HP: {player_hp}")
        
        active_mines.append(m)
    mines = active_mines
    
    # Check Death
    if player_hp <= 0: game_over = True

    # --- PARTICLE PHYSICS ---
    active_particles = []
    for p in particles:
        p['x'] += p['dx']
        p['y'] += p['dy']
        p['z'] += p['dz']
        p['dy'] -= 0.1 # Gravity
        p['life'] -= 1
        if p['life'] > 0 and p['y'] > 0: active_particles.append(p)
    particles = active_particles

def setup_camera():
    glMatrixMode(GL_PROJECTION); glLoadIdentity()
    gluPerspective(60, WINDOW_WIDTH/WINDOW_HEIGHT, 1, 1000)
    glMatrixMode(GL_MODELVIEW); glLoadIdentity()
    lx = player_pos[0] + math.sin(player_angle) * 100
    lz = player_pos[2] - math.cos(player_angle) * 100
    gluLookAt(player_pos[0], 25, player_pos[2], lx, 25, lz, 0, 1, 0)

# ==========================================
# Input Callbacks
# ==========================================
def keyDown(key, x, y):
    key_states[key] = True
    key_states[key.lower()] = True 
    if key == b'r': generate_level_3()

def keyUp(key, x, y): 
    key_states[key] = False
    key_states[key.lower()] = False

def specialDown(key, x, y): key_states[key] = True
def specialUp(key, x, y): key_states[key] = False

def showScreen():
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    setup_camera()
    if display_list is None: create_display_list()
    glCallList(display_list)
    draw_entities()
    draw_hud()
    glutSwapBuffers()

def idle():
    update_physics()
    glutPostRedisplay()

def main():
    glutInit()
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)
    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT)
    glutCreateWindow(b"Level 3: The Stone Labyrinth")
    glEnable(GL_DEPTH_TEST)
    generate_level_3()
    glutDisplayFunc(showScreen)
    glutIdleFunc(idle)
    glutKeyboardFunc(keyDown); glutKeyboardUpFunc(keyUp)
    glutSpecialFunc(specialDown); glutSpecialUpFunc(specialUp)
    glutMainLoop()

if __name__ == "__main__":
    main()