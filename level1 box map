from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *
from OpenGL.GLUT import GLUT_BITMAP_HELVETICA_18
import math
import random
import sys

sys.setrecursionlimit(2000)

# ==========================================
# Global Configuration
# ==========================================
WINDOW_WIDTH = 1024
WINDOW_HEIGHT = 768

# Scale Factors
MAP_DIM = 140       
CELL_SIZE = 30      
WALL_HEIGHT = 80    
FOV_Y = 90

# Cell Types
C_EMPTY = 0
C_WALL = 1
C_ACID = 2
C_BOSS = 3
C_START = 4
C_GATE = 5

# Map Data
map_data = []       
display_list = None 

# --- ENTITIES ---
enemies = []    
animals = []
gas_clouds = [] 
daggers = []
loot = []
particles = [] 
rain_drops = []
poison_ghosts = [] 

# --- GAME STATE ---
ghosts_captured = 0
boss_active = False
boss_defeated = False
boss_obj = {'x': 0, 'z': 0, 'hp': 2000, 'max_hp': 2000, 'timer': 0, 'teleport_cd': 0}
rain_active = False
rain_duration = 0

# --- PLAYER STATE ---
player_pos = [0, 0, 0]
player_angle = 1.57 
base_speed = 3.5 
player_speed = base_speed

enemy_speed = base_speed / 9.0 
animal_speed = base_speed / 3.0 
dagger_speed = 2.0 

key_states = {}

# Stats
player_hp = 100.0
player_ammo = 25 
inventory = [] 
immunity_timer = 0 
has_green_gem = False

# Stamina
player_stamina = 100.0
max_stamina = 100.0
is_exhausted = False
infinite_stamina_timer = 0 
is_sprinting = False 

# Animation & Cheats
global_time = 0.0
acid_level = 0.0
game_over = False
level_complete = False 
map_visible = False 

# ==========================================
# 1. Map Generation
# ==========================================
def generate_level_1():
    global map_data, player_pos, display_list, gas_clouds, enemies, animals, loot, particles, boss_obj, boss_active, boss_defeated, rain_drops, has_green_gem, poison_ghosts, ghosts_captured
    
    map_data = [[C_WALL for _ in range(MAP_DIM)] for _ in range(MAP_DIM)]
    gas_clouds = []; enemies = []; animals = []; loot = []; particles = []; rain_drops = []
    poison_ghosts = []; ghosts_captured = 0
    boss_active = False; boss_defeated = False; has_green_gem = False
    
    def dig_room(x, z, w, h, type=C_EMPTY):
        for i in range(w):
            for j in range(h):
                if 0 <= x+i < MAP_DIM and 0 <= z+j < MAP_DIM:
                    map_data[x+i][z+j] = type

    def dig_path(x1, z1, x2, z2):
        start_x, end_x = min(x1, x2), max(x1, x2)
        for x in range(start_x, end_x + 1):
            for w in range(-1, 2): 
                if 0 <= z1+w < MAP_DIM and map_data[x][z1+w] == C_WALL: map_data[x][z1+w] = C_EMPTY
        
        start_z, end_z = min(z1, z2), max(z1, z2)
        for z in range(start_z, end_z + 1):
            for w in range(-1, 2):
                if 0 <= x2+w < MAP_DIM and map_data[x2+w][z] == C_WALL: map_data[x2+w][z] = C_EMPTY
    
    rooms = []
    
    start_room = {'x': 5, 'z': 5, 'w': 10, 'h': 10, 'center': (10, 10)}
    dig_room(5, 5, 10, 10, C_START)
    rooms.append(start_room)
    
    boss_x, boss_z = MAP_DIM - 35, MAP_DIM - 35
    boss_room = {'x': boss_x, 'z': boss_z, 'w': 30, 'h': 30, 'center': (boss_x+15, boss_z+15)}

    attempts = 0
    while len(rooms) < 20 and attempts < 1000:
        attempts += 1
        w = random.randint(6, 12); h = random.randint(6, 12)
        x = random.randint(15, MAP_DIM - 40); z = random.randint(15, MAP_DIM - 40)
        
        overlap = False
        for r in rooms:
            if (x < r['x'] + r['w'] + 2 and x + w + 2 > r['x'] and
                z < r['z'] + r['h'] + 2 and z + h + 2 > r['z']):
                overlap = True; break
        
        if not overlap:
            dig_room(x, z, w, h, C_EMPTY)
            rooms.append({'x':x, 'z':z, 'w':w, 'h':h, 'center':(x + w//2, z + h//2)})

    rooms.append(boss_room)
    rooms.sort(key=lambda r: math.hypot(r['center'][0], r['center'][1]))
    
    for i in range(len(rooms) - 1):
        c1 = rooms[i]['center']; c2 = rooms[i+1]['center']
        dig_path(c1[0], c1[1], c2[0], c2[1])

    dig_room(boss_room['x'], boss_room['z'], boss_room['w'], boss_room['h'], C_BOSS)
    
    gx = boss_room['x'] - 1; gz_start = boss_room['z'] + 10
    for k in range(10):
        map_data[gx][gz_start + k] = C_GATE
        map_data[gx-1][gz_start + k] = C_EMPTY
        map_data[gx-2][gz_start + k] = C_EMPTY

    for x in range(MAP_DIM):
        for z in range(MAP_DIM):
            if map_data[x][z] == C_EMPTY:
                wx = x * CELL_SIZE; wz = z * CELL_SIZE
                if random.random() < 0.1: map_data[x][z] = C_ACID
                else:
                    r = random.random()
                    if r < 0.005: gas_clouds.append({'x': wx, 'z': wz, 'home_x': wx, 'home_z': wz, 'y_base': 50, 'dx': 0.2, 'dz': 0.2})
                    elif r < 0.015: enemies.append({'x': wx, 'z': wz, 'home_x': wx, 'home_z': wz})
                    elif r < 0.02: animals.append({'x': wx, 'z': wz, 'home_x': wx, 'home_z': wz, 'angle': 0, 'active': True})
                    elif r < 0.03: loot.append({'x': wx, 'z': wz, 'type': 'HP'})

    ghost_attempts = 0
    while len(poison_ghosts) < 3 and ghost_attempts < 1000:
        ghost_attempts += 1
        rx = random.randint(10, MAP_DIM-10); rz = random.randint(10, MAP_DIM-10)
        if map_data[rx][rz] == C_EMPTY:
            if math.sqrt((rx*CELL_SIZE - start_room['center'][0]*CELL_SIZE)**2 + (rz*CELL_SIZE - start_room['center'][1]*CELL_SIZE)**2) > 800:
                poison_ghosts.append({'x': rx*CELL_SIZE, 'z': rz*CELL_SIZE, 'life': 1})

    boss_obj['x'] = boss_room['center'][0] * CELL_SIZE
    boss_obj['z'] = boss_room['center'][1] * CELL_SIZE
    boss_obj['hp'] = 2000
    
    player_pos = [start_room['center'][0] * CELL_SIZE, 20, start_room['center'][1] * CELL_SIZE]
    
    if display_list:
        glDeleteLists(display_list, 1)
        display_list = None

# ==========================================
# 2. Visuals
# ==========================================
def create_display_list():
    global display_list
    display_list = glGenLists(1)
    glNewList(display_list, GL_COMPILE)
    
    for x in range(MAP_DIM):
        for z in range(MAP_DIM):
            cell = map_data[x][z]
            wx = x * CELL_SIZE
            wz = z * CELL_SIZE
            
            if cell == C_WALL:
                glPushMatrix()
                glTranslatef(wx, WALL_HEIGHT/2, wz)
                glScalef(1, WALL_HEIGHT/CELL_SIZE, 1) 
                glColor3f(0.45, 0.35, 0.25) 
                glutSolidCube(CELL_SIZE)
                glPopMatrix()
                
            elif cell == C_EMPTY or cell == C_START:
                if (x+z)%2 == 0: glColor3f(0.1, 0.3, 0.1) 
                else: glColor3f(0.15, 0.35, 0.15) 
                glBegin(GL_QUADS)
                glNormal3f(0, 1, 0)
                glVertex3f(wx-CELL_SIZE/2, 0, wz-CELL_SIZE/2); glVertex3f(wx+CELL_SIZE/2, 0, wz-CELL_SIZE/2)
                glVertex3f(wx+CELL_SIZE/2, 0, wz+CELL_SIZE/2); glVertex3f(wx-CELL_SIZE/2, 0, wz+CELL_SIZE/2)
                glEnd()
                
            elif cell == C_BOSS:
                glColor3f(0.2, 0.2, 0.2)
                glBegin(GL_QUADS)
                glNormal3f(0, 1, 0)
                glVertex3f(wx-CELL_SIZE/2, 0, wz-CELL_SIZE/2); glVertex3f(wx+CELL_SIZE/2, 0, wz-CELL_SIZE/2)
                glVertex3f(wx+CELL_SIZE/2, 0, wz+CELL_SIZE/2); glVertex3f(wx-CELL_SIZE/2, 0, wz+CELL_SIZE/2)
                glEnd()
                
            elif cell == C_GATE:
                glPushMatrix()
                glTranslatef(wx, WALL_HEIGHT/2, wz)
                glScalef(0.5, WALL_HEIGHT/CELL_SIZE, 1)
                glColor3f(0.0, 1.0, 0.5) 
                glutSolidCube(CELL_SIZE)
                glPopMatrix()
    glEndList()

def draw_entities():
    glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
    
    glColor4f(0.4, 1.0, 0.0, 0.8) 
    for x in range(MAP_DIM):
        for z in range(MAP_DIM):
            if map_data[x][z] == C_ACID:
                wx = x * CELL_SIZE; wz = z * CELL_SIZE
                glPushMatrix()
                pulse = math.sin(global_time * 2) * 2 - 5
                glTranslatef(wx, pulse, wz) 
                glBegin(GL_QUADS)
                glNormal3f(0, 1, 0)
                glVertex3f(wx-CELL_SIZE/2, 0, wz-CELL_SIZE/2); glVertex3f(wx+CELL_SIZE/2, 0, wz-CELL_SIZE/2)
                glVertex3f(wx+CELL_SIZE/2, 0, wz+CELL_SIZE/2); glVertex3f(wx-CELL_SIZE/2, 0, wz+CELL_SIZE/2)
                glEnd()
                glPopMatrix()
    
    glColor4f(0.6, 0.8, 0.6, 0.4) 
    for g in gas_clouds:
        glPushMatrix()
        glTranslatef(g['x'], g['y_base'] + math.sin(global_time)*3, g['z'])
        glutSolidSphere(12, 10, 10)
        glPopMatrix()
        
    glColor4f(0.0, 1.0, 0.8, 0.5) 
    for g in poison_ghosts:
        glPushMatrix()
        float_y = 60 + math.sin(global_time * 3) * 5
        glTranslatef(g['x'], float_y, g['z'])
        glutSolidSphere(10, 12, 12)
        glPushMatrix()
        glTranslatef(0, -5, 0)
        glRotatef(90, 1, 0, 0)
        glutSolidCone(6, 20, 8, 8)
        glPopMatrix()
        glColor4f(0.0, 1.0, 0.8, 0.7) 
        glPushMatrix(); glTranslatef(-8, 0, 0); glRotatef(45, 0, 0, 1); glScalef(0.5, 3, 0.5); glutSolidCube(4); glPopMatrix()
        glPushMatrix(); glTranslatef(8, 0, 0); glRotatef(-45, 0, 0, 1); glScalef(0.5, 3, 0.5); glutSolidCube(4); glPopMatrix()
        glColor4f(0.0, 1.0, 0.8, 0.5)
        glPopMatrix()

    glDisable(GL_BLEND)

    glColor3f(0.6, 0.0, 0.8) 
    for e in enemies:
        glPushMatrix()
        s = 1.0 + 0.1 * math.sin(global_time * 2)
        glTranslatef(e['x'], 5, e['z']) 
        glScalef(s * 1.2, s * 0.4, s * 1.2) 
        glutSolidSphere(10, 10, 10)
        glPopMatrix()

    for a in animals:
        if a['active']:
            glPushMatrix()
            glTranslatef(a['x'], 3, a['z'])
            glRotatef(math.degrees(a.get('angle', 0)), 0, 1, 0)
            glColor3f(0.6, 0.55, 0.5) 
            glPushMatrix(); glScalef(1, 0.7, 1.5); glutSolidCube(6); glPopMatrix() 
            glPushMatrix(); glTranslatef(0, 3, 3); glutSolidCube(4)
            glPushMatrix(); glTranslatef(-1, 2, 0); glRotatef(-90, 1, 0, 0); glutSolidCone(0.5, 3, 4, 4); glPopMatrix()
            glPushMatrix(); glTranslatef(1, 2, 0); glRotatef(-90, 1, 0, 0); glutSolidCone(0.5, 3, 4, 4); glPopMatrix()
            glPopMatrix() 
            glPushMatrix(); glTranslatef(0, 0, -4); glutSolidCone(1, 2, 4, 4); glPopMatrix() 
            for lx in [-2, 2]:
                for lz in [-2, 2]:
                    glPushMatrix(); glTranslatef(lx, -2, lz); glRotatef(90, 1, 0, 0); glutSolidCone(0.5, 2, 4, 4); glPopMatrix() 
            glPopMatrix()

    glColor3f(0.9, 0.9, 0.9) 
    for d in daggers:
        glPushMatrix()
        glTranslatef(d['x'], d['y'], d['z'])
        glRotatef(math.degrees(-d['angle']), 0, 1, 0) 
        glutSolidCone(1.5, 8, 8, 8) 
        glPopMatrix()
        
    for p in particles:
        glPushMatrix()
        glTranslatef(p['x'], p['y'], p['z'])
        s = p['life']/10.0
        glScalef(s, s, s) 
        glColor3f(1.0, p['life']/20.0, 0.0) 
        glutSolidCube(2)
        glPopMatrix()

    for l in loot:
        glPushMatrix()
        glTranslatef(l['x'], 10, l['z'])
        glRotatef(global_time * 50, 0, 1, 0) 
        if l['type'] == 'HP':
            glColor3f(1, 0, 0); glutSolidSphere(5, 8, 8)
        elif l['type'] == 'AMMO':
            glColor3f(0.5, 0.5, 0.5); glScalef(0.5, 2, 0.5); glutSolidCube(5)
        elif l['type'] == 'IMMUNITY':
            glColor3f(0.8, 0, 1); glutSolidTorus(2, 5, 8, 8)
        elif l['type'] == 'STAMINA':
            glColor3f(0.0, 1.0, 0.8); glScalef(0.5, 2, 0.5); glutSolidCube(5)
        elif l['type'] == 'GEM':
            glColor3f(0.0, 1.0, 0.0); glutSolidIcosahedron()
        elif l['type'] == 'BOTTLE':
            glColor3f(0.0, 0.5, 1.0); glScalef(0.6, 1.5, 0.6); glutSolidCube(6)
        elif l['type'] == 'DIAMOND_KEY':
            glColor3f(0.0, 1.0, 1.0); glScalef(1.5, 1.5, 1.5); glutSolidOctahedron()
        glPopMatrix()
        
    if boss_active or (not boss_defeated and in_boss_arena(player_pos, 1000)):
        glPushMatrix()
        glTranslatef(boss_obj['x'], 20 + math.sin(global_time)*2, boss_obj['z'])
        glScalef(2, 2, 2)
        glColor3f(0.4, 0.0, 0.4)
        glutSolidSphere(15, 16, 16)
        glColor3f(0.0, 1.0, 0.0)
        for ang in range(0, 360, 90):
             rad = math.radians(ang + global_time*50)
             ox = math.cos(rad) * 12; oz = math.sin(rad) * 12
             glPushMatrix(); glTranslatef(ox, 0, oz); glutSolidSphere(6, 10, 10); glPopMatrix()
        glPopMatrix()
        
    if rain_active:
        glLineWidth(1)
        glBegin(GL_LINES)
        glColor3f(0.2, 1.0, 0.2)
        for r in rain_drops:
            glVertex3f(r['x'], r['y'], r['z'])
            glVertex3f(r['x'], r['y']-15, r['z'])
        glEnd()

def draw_player_gun():
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()
    
    glTranslatef(0.2, -0.2, -0.5)
    glRotatef(-5, 0, 1, 0) 
    
    glColor3f(0.3, 0.3, 0.3) 
    glPushMatrix()
    glScalef(0.05, 0.05, 0.4)
    glutSolidCube(1)
    glPopMatrix()
    
    glColor3f(0.8, 0.6, 0.5)
    glPushMatrix()
    glTranslatef(0, -0.05, 0.1)
    glutSolidSphere(0.04, 8, 8)
    glPopMatrix()
    
    glPopMatrix()

def draw_minimap():
    glDisable(GL_DEPTH_TEST) 
    glMatrixMode(GL_PROJECTION); glPushMatrix(); glLoadIdentity()
    gluOrtho2D(0, WINDOW_WIDTH, 0, WINDOW_HEIGHT)
    glMatrixMode(GL_MODELVIEW); glPushMatrix(); glLoadIdentity()

    map_size = 150; margin = 20
    glColor3f(0.2, 0.2, 0.2)
    glBegin(GL_QUADS)
    glVertex2f(margin, margin); glVertex2f(margin+map_size, margin)
    glVertex2f(margin+map_size, margin+map_size); glVertex2f(margin, margin+map_size)
    glEnd()

    glColor3f(1, 1, 1); glLineWidth(2)
    glBegin(GL_LINE_LOOP)
    glVertex2f(margin, margin); glVertex2f(margin+map_size, margin)
    glVertex2f(margin+map_size, margin+map_size); glVertex2f(margin, margin+map_size)
    glEnd()

    world_max = MAP_DIM * CELL_SIZE
    px = (player_pos[0] / world_max) * map_size
    py = (player_pos[2] / world_max) * map_size
    
    glColor3f(0, 1, 0)
    glPushMatrix()
    glTranslatef(margin + px, margin + py, 0)
    glBegin(GL_TRIANGLE_FAN)
    for i in range(0, 360, 40):
        rad = math.radians(i)
        glVertex2f(math.cos(rad)*3, math.sin(rad)*3)
    glEnd()
    glPopMatrix()
    
    if not boss_defeated:
        bx = (boss_obj['x'] / world_max) * map_size
        bz = (boss_obj['z'] / world_max) * map_size
        glColor3f(1, 0, 0)
        glPushMatrix()
        glTranslatef(margin + bx, margin + bz, 0)
        glBegin(GL_QUADS)
        glVertex2f(-3, -3); glVertex2f(3, -3); glVertex2f(3, 3); glVertex2f(-3, 3)
        glEnd()
        glPopMatrix()

    if map_visible:
        glColor3f(0, 1, 1) 
        for g in poison_ghosts:
            gx = (g['x'] / world_max) * map_size
            gz = (g['z'] / world_max) * map_size
            glPushMatrix()
            glTranslatef(margin + gx, margin + gz, 0)
            glBegin(GL_QUADS)
            glVertex2f(-2, -2); glVertex2f(2, -2); glVertex2f(2, 2); glVertex2f(-2, 2)
            glEnd()
            glPopMatrix()

    glMatrixMode(GL_PROJECTION); glPopMatrix()
    glMatrixMode(GL_MODELVIEW); glPopMatrix()
    glEnable(GL_DEPTH_TEST) 

def draw_hud():
    glMatrixMode(GL_PROJECTION); glPushMatrix(); glLoadIdentity()
    gluOrtho2D(0, WINDOW_WIDTH, 0, WINDOW_HEIGHT)
    glMatrixMode(GL_MODELVIEW); glPushMatrix(); glLoadIdentity()
    glDisable(GL_DEPTH_TEST)

    glColor3f(1, 0, 0)
    glRasterPos2f(20, WINDOW_HEIGHT - 30)
    for ch in f"HP: {int(player_hp)}": glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))
    
    bar_x = 100; bar_y = WINDOW_HEIGHT - 30; bar_w = 100; bar_h = 10
    glColor3f(0.3, 0.3, 0.3)
    glBegin(GL_QUADS)
    glVertex2f(bar_x, bar_y); glVertex2f(bar_x + bar_w, bar_y)
    glVertex2f(bar_x + bar_w, bar_y + bar_h); glVertex2f(bar_x, bar_y + bar_h)
    glEnd()
    
    if infinite_stamina_timer > 0: glColor3f(0, 1, 1) 
    elif is_exhausted: glColor3f(1, 0, 0) 
    else: glColor3f(1, 1, 0) 
        
    fill_w = (player_stamina / max_stamina) * bar_w
    glBegin(GL_QUADS)
    glVertex2f(bar_x, bar_y); glVertex2f(bar_x + fill_w, bar_y)
    glVertex2f(bar_x + fill_w, bar_y + bar_h); glVertex2f(bar_x, bar_y + bar_h)
    glEnd()
    
    glColor3f(1, 1, 1)
    glRasterPos2f(bar_x + 110, bar_y)
    status_msg = "INF STM" if infinite_stamina_timer > 0 else "TIRED" if is_exhausted else "STM"
    for ch in status_msg: glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))

    glColor3f(1, 1, 1)
    glRasterPos2f(20, WINDOW_HEIGHT - 60)
    for ch in f"Daggers: {player_ammo}": glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))

    bag_content = ", ".join([str(item) for item in inventory])
    glRasterPos2f(20, WINDOW_HEIGHT - 90)
    for ch in f"Bag: {bag_content}": glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))

    glColor3f(0, 1, 1)
    glRasterPos2f(20, WINDOW_HEIGHT - 150)
    for ch in f"Ghosts Captured: {ghosts_captured}/3": glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))

    if immunity_timer > 0:
        glColor3f(0, 1, 0)
        glRasterPos2f(20, WINDOW_HEIGHT - 120)
        msg = f"IMMUNITY: {int(immunity_timer/60)}s"
        for ch in msg: glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))
        
    if has_green_gem:
        glColor3f(0, 1, 0)
        glRasterPos2f(20, WINDOW_HEIGHT - 180)
        for ch in "GEM ACQUIRED! GATE OPEN!": glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))

    if game_over:
        glColor3f(1, 0, 0)
        glRasterPos2f(WINDOW_WIDTH/2 - 50, WINDOW_HEIGHT/2)
        for ch in "GAME OVER": glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, ord(ch))
        
    if level_complete:
        glColor3f(0, 1, 0)
        glRasterPos2f(WINDOW_WIDTH/2 - 80, WINDOW_HEIGHT/2)
        for ch in "LEVEL COMPLETE!": glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, ord(ch))

    glEnable(GL_DEPTH_TEST)
    glMatrixMode(GL_PROJECTION); glPopMatrix()
    glMatrixMode(GL_MODELVIEW); glPopMatrix()

# ==========================================
# 3. Logic & Physics
# ==========================================
def in_boss_arena(pos, padding=0):
    bx = (MAP_DIM - 25) * CELL_SIZE
    bz = (MAP_DIM - 25) * CELL_SIZE
    half_size = 15 * CELL_SIZE + padding
    return (bx - half_size < pos[0] < bx + half_size) and (bz - half_size < pos[2] < bz + half_size)

def close_boss_gate():
    global display_list
    cx = MAP_DIM - 25
    cy = MAP_DIM - 25
    r = 15
    for i in range(-r, r+1):
        for j in range(-r, r+1):
            if abs(i) == r or abs(j) == r:
                if 0 <= cx+i < MAP_DIM and 0 <= cy+j < MAP_DIM:
                     if map_data[cx+i][cy+j] == C_EMPTY:
                        map_data[cx+i][cy+j] = C_WALL
                    
    if display_list:
        glDeleteLists(display_list, 1)
        display_list = None
        create_display_list()

def check_sprint():
    global is_sprinting
    if glutGetModifiers() & GLUT_ACTIVE_SHIFT:
        is_sprinting = True
    else:
        is_sprinting = False

def update_physics():
    global player_pos, player_angle, global_time, acid_level, player_hp, max_player_hp, game_over, level_complete
    global enemies, animals, gas_clouds, daggers, loot, immunity_timer, player_ammo, inventory, particles
    global player_stamina, is_exhausted, infinite_stamina_timer, is_sprinting, player_speed
    global boss_active, boss_defeated, boss_obj, rain_active, rain_duration, rain_drops, has_green_gem, boss_speed, poison_ghosts
    
    if game_over or level_complete: return

    global_time += 0.05
    acid_level = math.sin(global_time) * 3 
    if immunity_timer > 0: immunity_timer -= 1
    if infinite_stamina_timer > 0: infinite_stamina_timer -= 1

    # Boss Trigger
    if not boss_active and not boss_defeated:
        if in_boss_arena(player_pos):
            boss_active = True
            close_boss_gate()

    # Boss Logic
    if boss_active:
        boss_obj['timer'] += 1
        dx = boss_obj['x'] - player_pos[0]
        dz = boss_obj['z'] - player_pos[2]
        dist = math.sqrt(dx*dx + dz*dz)
        
        if dist < 250:
            if dist > 0: dx /= dist; dz /= dist
            boss_obj['x'] -= dx * boss_speed
            boss_obj['z'] -= dz * boss_speed
            
            gx = int(round(boss_obj['x'] / CELL_SIZE))
            gz = int(round(boss_obj['z'] / CELL_SIZE))
            if map_data[gx][gz] not in [C_BOSS, C_EMPTY]:
                 boss_obj['x'] += dx * boss_speed
                 boss_obj['z'] += dz * boss_speed
                 
        if boss_obj['teleport_cd'] <= 0 and dist < 80:
             cx = MAP_DIM - 25
             cy = MAP_DIM - 25
             rx = random.randint(cx-10, cx+10)
             ry = random.randint(cy-10, cy+10)
             boss_obj['x'] = rx * CELL_SIZE
             boss_obj['z'] = ry * CELL_SIZE
             boss_obj['teleport_cd'] = 200
             for _ in range(20): particles.append({'x': boss_obj['x'], 'y': 10, 'z': boss_obj['z'], 'life': 30, 'dx': random.uniform(-2,2), 'dy': random.uniform(-2,2), 'dz': random.uniform(-2,2)})

        if boss_obj['teleport_cd'] > 0: boss_obj['teleport_cd'] -= 1

        if boss_obj['timer'] % 800 == 0: 
            rain_active = True
            rain_duration = 300
        if boss_obj['timer'] % 600 == 0: 
             enemies.append({'x': boss_obj['x'], 'z': boss_obj['z'], 'home_x': boss_obj['x'], 'home_z': boss_obj['z']})
        if boss_obj['timer'] % 600 == 0:
             gas_clouds.append({'x': boss_obj['x'], 'z': boss_obj['z'], 'home_x': boss_obj['x'], 'home_z': boss_obj['z'], 'y_base': 20, 'dx': random.uniform(-1,1), 'dz': random.uniform(-1,1), 'type': 'BOSS', 'life': 600})

    if rain_active:
        rain_duration -= 1
        if rain_duration <= 0: rain_active = False
        if immunity_timer <= 0: player_hp -= 0.05
        for _ in range(5):
             rain_drops.append({'x': player_pos[0]+random.randint(-200,200), 'y': 200, 'z': player_pos[2]+random.randint(-200,200)})
        new_rain = []
        for r in rain_drops:
            r['y'] -= 5
            if r['y'] > 0: new_rain.append(r)
        rain_drops = new_rain

    # Movement
    move_speed = 0; strafe = 0
    is_moving = key_states.get(b'w') or key_states.get(b's') or key_states.get(b'a') or key_states.get(b'd')
    
    if infinite_stamina_timer > 0:
        player_speed = base_speed * 2.0 if is_sprinting else base_speed
        player_stamina = 100; is_exhausted = False
    else:
        if is_sprinting and is_moving and not is_exhausted:
            player_speed = base_speed * 2.0
            player_stamina -= 0.16 
            if player_stamina <= 0: player_stamina = 0; is_exhausted = True
        elif is_exhausted:
            player_speed = base_speed * 0.5
            player_stamina += 0.05
            if player_stamina >= 30: is_exhausted = False
        else:
            player_speed = base_speed
            if not is_sprinting: player_stamina = min(100, player_stamina + 0.1)

    if key_states.get(b'w'): move_speed = player_speed
    if key_states.get(b's'): move_speed = -player_speed
    if key_states.get(b'a'): strafe = -player_speed
    if key_states.get(b'd'): strafe = player_speed
    
    if key_states.get(GLUT_KEY_LEFT): player_angle -= 0.04
    if key_states.get(GLUT_KEY_RIGHT): player_angle += 0.04
    
    dx = math.sin(player_angle) * move_speed
    dz = -math.cos(player_angle) * move_speed
    sdx = math.sin(player_angle + 1.57) * strafe
    sdz = -math.cos(player_angle + 1.57) * strafe
    
    nx = player_pos[0] + dx + sdx
    nz = player_pos[2] + dz + sdz
    
    gx = int(round(nx / CELL_SIZE))
    gz = int(round(nz / CELL_SIZE))
    
    can_move_x = True
    gz_curr = int(round(player_pos[2] / CELL_SIZE))
    if 0 <= gx < MAP_DIM and 0 <= gz_curr < MAP_DIM:
        cell = map_data[gx][gz_curr]
        if cell == C_WALL: can_move_x = False
        elif cell == C_GATE and ghosts_captured < 3: can_move_x = False
    
    if can_move_x: player_pos[0] = nx

    can_move_z = True
    gx_curr = int(round(player_pos[0] / CELL_SIZE))
    if 0 <= gx_curr < MAP_DIM and 0 <= gz < MAP_DIM:
        cell = map_data[gx_curr][gz]
        if cell == C_WALL: can_move_z = False
        elif cell == C_GATE and ghosts_captured < 3: can_move_z = False

    if can_move_z: player_pos[2] = nz
        
    if map_data[gx_curr][gz] == C_ACID and immunity_timer <= 0:
            player_hp -= 0.05

    # Poison Ghosts AI (FIXED: Flee Logic)
    for g in poison_ghosts:
        # Distance to player
        dx = player_pos[0] - g['x']
        dz = player_pos[2] - g['z']
        dist = math.sqrt(dx*dx + dz*dz)
        
        move_x = 0; move_y = 0
        
        # Stalk Logic:
        # If far (> 300), move closer
        # If close (< 100), flee
        # Else, roam
        
        if dist > 300:
            move_x = (dx / dist) * (base_speed * 0.5)
            move_y = (dz / dist) * (base_speed * 0.5)
        elif dist < 100:
             # Flee away from player
             move_x = -(dx / dist) * (base_speed * 0.5)
             move_y = -(dz / dist) * (base_speed * 0.5)
        else:
             move_x = random.uniform(-1, 1)
             move_y = random.uniform(-1, 1)
             
        nx = g['x'] + move_x
        nz = g['z'] + move_y
        
        # Check Collision (Don't enter Boss Arena or Walls)
        # We assume they can pass walls per requirement, BUT
        # "must not enter boss arena" was requested.
        
        if not in_boss_arena([nx, 0, nz], padding=20):
             g['x'] = nx
             g['z'] = nz
             
        # Clamp to Map
        g['x'] = max(CELL_SIZE, min(g['x'], (MAP_DIM-1)*CELL_SIZE))
        g['z'] = max(CELL_SIZE, min(g['z'], (MAP_DIM-1)*CELL_SIZE))


    # Gas
    active_gas = []
    for g in gas_clouds:
        g['x'] += g['dx']; g['z'] += g['dz']
        if g.get('type') == 'BOSS':
             g['life'] -= 1
             if g['life'] <= 0: continue
        else:
             if math.sqrt((g['x']-g['home_x'])**2 + (g['z']-g['home_z'])**2) > 50: g['dx']*=-1; g['dz']*=-1
        
        if math.sqrt((player_pos[0]-g['x'])**2 + (player_pos[2]-g['z'])**2) < 20 and immunity_timer <= 0: player_hp -= 0.3
        else: active_gas.append(g)
    gas_clouds = active_gas

    # Enemies
    new_enemies = []
    for e in enemies:
        dist = math.sqrt((player_pos[0]-e['x'])**2 + (player_pos[2]-e['z'])**2)
        if dist < 15: player_hp -= 0.5; continue
        if dist < 200:
             if math.sqrt((e['x']-e['home_x'])**2 + (e['z']-e['home_z'])**2) < 300:
                 ex = (player_pos[0]-e['x'])/dist; ez = (player_pos[2]-e['z'])/dist
                 e['x'] += ex * enemy_speed; e['z'] += ez * enemy_speed
        new_enemies.append(e)
    enemies = new_enemies

    # Animals
    for a in animals:
        if a['active']:
            dist = math.sqrt((player_pos[0]-a['x'])**2 + (player_pos[2]-a['z'])**2)
            if dist < 120:
                ex = (a['x'] - player_pos[0]) / dist
                ez = (a['z'] - player_pos[2]) / dist
                a['angle'] = math.atan2(ex, ez)
                nx = a['x'] + ex * animal_speed; nz = a['z'] + ez * animal_speed
                gx = int(round(nx / CELL_SIZE)); gz = int(round(nz / CELL_SIZE))
                if 0 <= gx < MAP_DIM and 0 <= gz < MAP_DIM and map_data[gx][gz] not in [C_WALL, C_GATE]:
                    a['x'] = nx; a['z'] = nz
                else:
                    a['x'] += random.choice([-1, 1]); a['z'] += random.choice([-1, 1])
        else:
            if math.sqrt((player_pos[0]-a['home_x'])**2 + (player_pos[2]-a['home_z'])**2) > 250:
                a['active'] = True; a['x'] = a['home_x']; a['z'] = a['home_z']

    # Daggers
    kept_daggers = []
    for d in daggers:
        d['x'] += math.sin(d['angle']) * dagger_speed
        d['z'] -= math.cos(d['angle']) * dagger_speed
        d['y'] -= 0.1; d['life'] -= 1
        hit = False
        gx = int(round(d['x'] / CELL_SIZE)); gz = int(round(d['z'] / CELL_SIZE))
        if 0 <= gx < MAP_DIM and 0 <= gz < MAP_DIM and map_data[gx][gz] in [C_WALL, C_GATE]: hit = True
        
        if not hit:
            if boss_active:
                if math.sqrt((d['x']-boss_obj['x'])**2 + (d['z']-boss_obj['z'])**2) < 20:
                    hit = True
                    boss_obj['hp'] -= 50
                    for _ in range(10): particles.append({'x': boss_obj['x'], 'y': 20, 'z': boss_obj['z'], 'life': 20, 'dx': random.uniform(-2,2), 'dy': random.uniform(-2,2), 'dz': random.uniform(-2,2)})
                    if boss_obj['hp'] <= 0:
                        boss_active = False; boss_defeated = True; rain_active = False
                        loot.append({'x': boss_obj['x'], 'z': boss_obj['z'], 'type': 'DIAMOND_KEY'})
                        max_stamina = 120; player_stamina = 120
                        max_player_hp = 120; player_hp = 120

            remaining = []
            for e in enemies:
                if math.sqrt((d['x']-e['x'])**2 + (d['z']-e['z'])**2) < 20:
                    hit = True
                    for _ in range(8): particles.append({'x': e['x'], 'y': 10, 'z': e['z'], 'life': 20, 'dx': random.uniform(-1,1), 'dy': random.uniform(0,2), 'dz': random.uniform(-1,1)})
                    r = random.random()
                    if r < 0.1: loot.append({'x': e['x'], 'z': e['z'], 'type': 'BOTTLE'}) 
                    elif r < 0.3: loot.append({'x': e['x'], 'z': e['z'], 'type': 'HP'})
                    elif r < 0.8: loot.append({'x': e['x'], 'z': e['z'], 'type': 'AMMO'}) 
                    elif r < 0.95: loot.append({'x': e['x'], 'z': e['z'], 'type': 'IMMUNITY'})
                    elif r < 0.99: loot.append({'x': e['x'], 'z': e['z'], 'type': 'STAMINA'})
                else: remaining.append(e)
            enemies = remaining

        if not hit:
            for a in animals:
                if a['active'] and math.sqrt((d['x']-a['x'])**2 + (d['z']-a['z'])**2) < 15:
                    hit = True; a['active'] = False
                    r = random.random()
                    if r < 0.4: loot.append({'x': a['x'], 'z': a['z'], 'type': 'BOTTLE'})
                    elif r < 0.7: loot.append({'x': a['x'], 'z': a['z'], 'type': 'HP'})

        if not hit and d['life'] > 0 and d['y'] > 0: kept_daggers.append(d)
    daggers = kept_daggers

    # Particles
    active_p = []
    for p in particles:
        p['x'] += p['dx']; p['y'] += p['dy']; p['z'] += p['dz']; p['life'] -= 1
        if p['life'] > 0: active_p.append(p)
    particles = active_p

    # Loot
    kept_loot = []
    for l in loot:
        if math.sqrt((player_pos[0]-l['x'])**2 + (player_pos[2]-l['z'])**2) < 20:
            if l['type'] == 'HP': 
                if player_hp >= max_player_hp: inventory.append("HP Pill")
                else: player_hp = min(max_player_hp, player_hp + 20)
            elif l['type'] == 'AMMO': player_ammo += 20
            elif l['type'] == 'IMMUNITY': inventory.append("Immunity")
            elif l['type'] == 'STAMINA': inventory.append("Stamina Pill")
            elif l['type'] == 'BOTTLE': inventory.append("Capture Bottle")
            elif l['type'] == 'GEM': has_green_gem = True; inventory.append("Green Gem")
            elif l['type'] == 'DIAMOND_KEY': inventory.append("Diamond Key")
        else: kept_loot.append(l)
    loot = kept_loot

    if player_hp <= 0: game_over = True

def setup_camera():
    glMatrixMode(GL_PROJECTION); glLoadIdentity()
    gluPerspective(60, WINDOW_WIDTH/WINDOW_HEIGHT, 1, 2000)
    glMatrixMode(GL_MODELVIEW); glLoadIdentity()
    lx = player_pos[0] + math.sin(player_angle) * 100
    lz = player_pos[2] - math.cos(player_angle) * 100
    gluLookAt(player_pos[0], 25, player_pos[2], lx, 25, lz, 0, 1, 0)

# ==========================================
# Standard Callbacks
# ==========================================
def showScreen():
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    setup_camera()
    
    # Lighting
    glEnable(GL_LIGHTING); glEnable(GL_LIGHT0)
    glLightfv(GL_LIGHT0, GL_POSITION, (0, 100, 0, 1))
    glEnable(GL_COLOR_MATERIAL)
    
    if display_list is None: create_display_list()
    glCallList(display_list)
    draw_player_gun()
    draw_entities()
    if map_visible: draw_minimap()
    draw_hud()
    glutSwapBuffers()

def idle(): update_physics(); glutPostRedisplay()

def keyDown(key, x, y):
    global player_ammo, immunity_timer, player_hp, infinite_stamina_timer, ghosts_captured, poison_ghosts, inventory, map_visible
    check_sprint()
    key_states[key] = True; key_states[key.lower()] = True
    if key == b'r': generate_level_1()
    
    # Capture Logic (Key 4)
    if key == b'4':
         if "Capture Bottle" in inventory and ghosts_captured < 3:
             # Find nearest ghost in field of view
             # Vector Player to Ghost
             p_dx = math.sin(player_angle)
             p_dz = -math.cos(player_angle)
             
             for g in poison_ghosts:
                 gx = g['x'] - player_pos[0]
                 gz = g['z'] - player_pos[2]
                 dist = math.sqrt(gx*gx + gz*gz)
                 
                 # Range Check
                 if dist < 80:
                     # Angle Check (Dot Product)
                     # Normalize ghost vector
                     if dist > 0:
                         gx /= dist
                         gz /= dist
                     
                     dot = p_dx * gx + p_dz * gz
                     
                     # 0.7 approx 45 degrees
                     if dot > 0.7:
                         inventory.remove("Capture Bottle")
                         poison_ghosts.remove(g)
                         ghosts_captured += 1
                         print(f"Ghost Captured! {ghosts_captured}/3")
                         break
         else:
             print("Need a Bottle or Already Full!")
        
    if key == b'c': map_visible = not map_visible
    if key == b'1' and "Immunity" in inventory: inventory.remove("Immunity"); immunity_timer = 3600
    if key == b'2' and "HP Pill" in inventory and player_hp < 100: inventory.remove("HP Pill"); player_hp = min(100, player_hp+20)
    if key == b'3' and "Stamina Pill" in inventory: inventory.remove("Stamina Pill"); infinite_stamina_timer = 1800

def keyUp(key, x, y): check_sprint(); key_states[key] = False; key_states[key.lower()] = False
def specialDown(key, x, y): check_sprint(); key_states[key] = True
def specialUp(key, x, y): check_sprint(); key_states[key] = False

def mouseListener(button, state, x, y):
    global player_ammo
    if button == GLUT_LEFT_BUTTON and state == GLUT_DOWN and not game_over:
        if player_ammo > 0:
            player_ammo -= 1
            daggers.append({'x': player_pos[0], 'y': 20, 'z': player_pos[2], 'angle': player_angle, 'life': 100})

def init_fog():
    glEnable(GL_FOG); glFogfv(GL_FOG_COLOR, (0.05, 0.15, 0.05, 1.0))
    glFogi(GL_FOG_MODE, GL_LINEAR); glFogf(GL_FOG_START, 100.0); glFogf(GL_FOG_END, 1200.0)
    glClearColor(0.05, 0.15, 0.05, 1.0)

def main():
    glutInit(); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)
    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT)
    glutCreateWindow(b"The Cursed Labyrinth")
    glEnable(GL_DEPTH_TEST); init_fog(); generate_level_1()
    glutDisplayFunc(showScreen); glutIdleFunc(idle)
    glutKeyboardFunc(keyDown); glutKeyboardUpFunc(keyUp)
    glutSpecialFunc(specialDown); glutSpecialUpFunc(specialUp)
    glutMouseFunc(mouseListener); glutMainLoop()

if __name__ == "__main__": main()